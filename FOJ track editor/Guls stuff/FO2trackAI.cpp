//
//-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// File        : $Id: FO2trackAI.cpp 446 2008-05-22 18:15:19Z GulBroz $
//   Revision  : $Revision: 446 $
//   Name      : $Name$
//
// Description : Class bodies to access FlatOut2 trackai.bin file
// Author      : 
// Date        : Wed Jan 10 22:21:52 2007
// Reader      : 
// Evolutions  : 
//
//  $Log$
//  Revision 1.3  2007/11/27 18:52:49  GulBroz
//  + Begin support for FO2 cars
//
//  Revision 1.2  2007/03/19 00:07:27  GulBroz
//    + Fix AI_Border_Left reading from Blender
//
//  Revision 1.1  2007/03/13 21:27:58  GulBroz
//    + Port to Blender 2.43
//
//  ----- Switch to Blender 2.43
//
//  Revision 1.4  2007/02/25 22:53:51  GulBroz
//    + Fix AltRoute index in .bed files
//    + Make raceline optional (compute for trackai.bin, skip in .bed files)
//
//  Revision 1.3  2007/02/20 19:48:52  GulBroz
//    + Add export and load to AI .bed files
//
//  Revision 1.2  2007/02/17 17:03:27  GulBroz
//    + AI stuff (almost final)
//
//  Revision 1.1  2007/01/22 22:15:46  GulBroz
//    + Add AI stuff
//
//-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//

//
//=============================================================================
//                              INCLUDE FILES
//=============================================================================
//
#include <math.h>

#include "FO2data.h"
#include "FO2trackAI.h"

#if !defined(NO_BLENDER)

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include "MEM_guardedalloc.h"
#include "MTC_matrixops.h"

#include "DNA_object_types.h"
#include "DNA_curve_types.h"
#include "DNA_mesh_types.h"
#include "DNA_scene_types.h"

#include "BKE_main.h"
#include "BKE_global.h"
#include "BKE_library.h" // rename_id()
#include "BKE_object.h"
#include "BKE_curve.h"
#include "BKE_mesh.h"
#include "BKE_scene.h"

#include "BIF_editmesh.h"

#include "BLI_blenlib.h"  // BLI_addhead()
#include "BLI_arithb.h"

#include "blendef.h" // BASEACT, FIRSTBASE

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // NO_BLENDER

//
//=============================================================================
//                                CONSTANTS
//=============================================================================
//
#define AI_TRACKAI_DIR      "data"
#define AI_TRACKAI_FILE     "trackai.bin"
#define AI_SPLINES_BED_FILE "splines.ai"
#define AI_STARTPT_BED_FILE "startpoints.bed"
#define AI_SPLITPT_BED_FILE "splitpoints.bed"

#define TE_GENERATED "File generated by Blender Track Editor"

//
//=============================================================================
//                      TYPE DEFINITIONS AND GLOBAL DATA
//=============================================================================
//

//
//=============================================================================
//                            INTERNAL ROUTINES
//=============================================================================
//

//
//=============================================================================
//                                ROUTINES
//=============================================================================
//

//-----------------------------------------------------------------------------
// Name   : cSplinePoints::cSplinePoints
// Usage  : cSplinePoints class constructor
// Args   : None
// Return : Nothing
//-----------------------------------------------------------------------------
cSplinePoints::cSplinePoints()
{
    dwStart   = AI_SPLINE_PT_START;
    dwNextIdx = dwZero1 = 0;
    dwPrevIdx = dwZero2 = 0;
    memset( dwUnk1, 0, sizeof(dwUnk1) );
    memset( dwUnk2, 0, sizeof(dwUnk2) );
    dwEnd     = AI_SPLINE_PT_END;

    _index = _filePos = _raceLine = 0;
} // End proc cSplinePoints::cSplinePoints

//-----------------------------------------------------------------------------
// Name   : cSplinePoints::read
// Usage  : Read cSplinePoints from file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         h                X   X   File handler
//         
// Return : 0 == OK / -1 == read error / -2 == id error
//-----------------------------------------------------------------------------
int cSplinePoints::read( FILE * h ) {
    int rtn = -1;
    uint i = 0;

    do {
        _filePos = ftell( h );

        if( 1 != fread( &dwStart, sizeof(dwStart), 1, h )) break;
        if( AI_SPLINE_PT_START != dwStart ) { rtn = -2; break; }
        
        if( 1 != fread( &dwNextIdx, sizeof(dwNextIdx), 1, h )) break;
        if( 1 != fread( &dwZero1,   sizeof(dwZero1), 1, h ))  break;
        if( 1 != fread( &dwPrevIdx, sizeof(dwPrevIdx), 1, h )) break;
        if( 1 != fread( &dwZero2,   sizeof(dwZero2), 1, h ))  break;
        if( 0 != m1.read( h ))  break;
        for( i = 0; i < 5; ++i ) {
            if( 0 != p[i].read( h )) break;
        }
        if( 5 != i ) break;
        if( 0 != m2.read( h ))  break;
        if( 1 != fread( dwUnk1,  sizeof(dwUnk1),  1, h ))    break;
        if( 1 != fread( dwUnk2,  sizeof(dwUnk2),  1, h ))    break;

        if( 1 != fread( &dwEnd, sizeof(dwEnd), 1, h )) break;
        if( AI_SPLINE_PT_END != dwEnd ) { rtn = -2; break; }

        rtn = 0;
    } while(0);

    return( rtn );
} // End proc cSplinePoints::read

//-----------------------------------------------------------------------------
// Name   : cSplinePoints::write
// Usage  : Write cSplinePoints to file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         h                X   X   File handler
//         
// Return : 0 == OK / -1 == write error / -2 == id error
//-----------------------------------------------------------------------------
int  cSplinePoints::write( FILE * h )
{
    int rtn = -1;
    uint i = 0;

    do {
#if 0
// #ifdef WITH_FO2_DBG
        printf( "++> Writing cSplinePoints "
                "dwStart=0x%08x dwEnd=0x%08x "
                "AI_SPLINE_PT_START=0x%08x AI_SPLINE_PT_END=0x%08x\n",
                dwStart, dwEnd, AI_SPLINE_PT_START, AI_SPLINE_PT_END );
#endif // WITH_FO2_DBG

        if( AI_SPLINE_PT_START != dwStart ||
            AI_SPLINE_PT_END   != dwEnd ) { rtn = -2; break; }

        if( 1 != fwrite( &dwStart, sizeof(dwStart), 1, h )) break;
        
        if( 1 != fwrite( &dwNextIdx, sizeof(dwNextIdx), 1, h )) break;
        if( 1 != fwrite( &dwZero1,   sizeof(dwZero1), 1, h ))  break;
        if( 1 != fwrite( &dwPrevIdx, sizeof(dwPrevIdx), 1, h )) break;
        if( 1 != fwrite( &dwZero2,   sizeof(dwZero2), 1, h ))  break;
        if( 0 != m1.write( h ))  break;
        for( i = 0; i < 5; ++i ) {
            if( 0 != p[i].write( h )) break;
        }
        if( 5 != i ) break;
        if( 0 != m2.write( h ))  break;
        if( 1 != fwrite( dwUnk1,  sizeof(dwUnk1),  1, h ))  break;
        if( 1 != fwrite( dwUnk2,  sizeof(dwUnk2),  1, h ))  break;

        if( 1 != fwrite( &dwEnd, sizeof(dwEnd), 1, h )) break;

        rtn = 0;
    } while(0);

    return( rtn );
} // End proc cSplinePoints::write

//-----------------------------------------------------------------------------
// Name   : cSplinePoints::show
// Usage  : Dump cSplinePoints to screen
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         tab              X   -   (Optional) number of tabs before printing
//         where            X   -   (Optional) where to send data
//         
// Return : Nothing
//-----------------------------------------------------------------------------
void cSplinePoints::show( const uint tab, FILE *where )
{
    const char * myTab = TABS(tab);
    FILE *out = ( where ? where : stdout );
    uint i;

    fprintf(out, "%s{ -- splinePoint #%d (@ 0x%08x)\n",
            myTab, _index, _filePos );
    fprintf(out, "%s\tdwStart   = 0x%08x\n", myTab, dwStart );
    fprintf(out, "%s\tdwNextIdx = 0x%08x (%d)\n", myTab, dwNextIdx, dwNextIdx);
    fprintf(out, "%s\tdwZero1   = 0x%08x\n",      myTab, dwZero1 );
    fprintf(out, "%s\tdwPrevIdx = 0x%08x (%d)\n", myTab, dwPrevIdx, dwPrevIdx);
    fprintf(out, "%s\tdwZero2   = 0x%08x\n",      myTab, dwZero2 );

    fprintf(out, "%s\tm1 = { ", myTab );
    m1.show( tab + 1, out );
    fprintf(out, "}\n" );
    for( i = 0; i < 5; ++i ) {
        fprintf(out, "%s\tp[%d] = { ", myTab, i );
        p[i].show("", out );
        fprintf(out, "}\n" );
    }
    fprintf(out, "%s\tm2 = { ", myTab );
    m2.show( tab + 1, out );
    fprintf(out, "}\n" );
    for( i = 0; i < 9; ++i ) {
        fprintf(out, "%s\tdwUnk1[%d] = %f (0x%08x)\n", myTab,
                i, dwUnk1[i], *((uint*)&dwUnk1[i]) );
    }
    for( i = 0; i < 4; ++i ) {
        fprintf(out, "%s\tdwUnk2[%d] = 0x%08x (%d) %f\n", myTab,
                i, dwUnk2[i], dwUnk2[i], *((float*)&dwUnk2[i]) );
    }
    fprintf(out, "%s\t_raceLine = 0x%08x\n", myTab, _raceLine );
    fprintf(out, "%s\tdwEnd     = 0x%08x\n", myTab, dwEnd );

    fprintf( out,
             "%s},\n", myTab );

    fflush( out );
} // End proc cSplinePoints::show

//-----------------------------------------------------------------------------
// Name   : cSplineList::cSplineList
// Usage  : cSplineList class constructor
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         idx              X   -   Index of splineList in list
//
// Return : Nothing
//-----------------------------------------------------------------------------
cSplineList::cSplineList( const uint idx )
{
    dwStart   = AI_SPLINES_START;
    dwNPoints = 0;
    memset( dwUnknown, 0, sizeof(dwUnknown) );
    dwEnd     = AI_SPLINES_END;

    _index   = idx;
    _filePos = 0;
} // End proc cSplineList::cSplineList

//-----------------------------------------------------------------------------
// Name   : cSplineList::read
// Usage  : Read cSplineList from file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         h                X   X   File handler
//         
// Return : 0 == OK / -1 == read error / -2 == id error / -3 == memory error
//-----------------------------------------------------------------------------
int cSplineList::read( FILE * h )
{
    int rtn = 0;
    cSplinePoints sp;

    do {
        splinePoints.clear(); dwNPoints = 0;
        _filePos = ftell( h );

        if( 1 != fread( &dwStart, sizeof(dwStart), 1, h )) { rtn = -1; break; }
        if( AI_SPLINES_START != dwStart ) { rtn = -2; break; }

        if( 1 != fread( &dwNPoints, sizeof(dwNPoints), 1, h )) {
            rtn = -1;
            break;
        }

        if( dwNPoints ) {
            splinePoints.reserve( dwNPoints );
            if( splinePoints.capacity() < dwNPoints ) { rtn = -3; break; }

            rtn = 0;
            for( uint i = 0; 0 == rtn && i < dwNPoints; ++i ) {
                sp._index = i;
                rtn = sp.read( h );
                if( 0 == rtn ) splinePoints.push_back( sp );
            } // End for
            if( 0 != rtn ) break;
        } // End if

        if( 1 != fread( dwUnknown,  sizeof(dwUnknown),  1, h )) {
            rtn = -1;
            break;
        }

        if( 1 != fread( &dwEnd, sizeof(dwEnd), 1, h )) break;
        if( AI_SPLINES_END != dwEnd ) { rtn = -2; break; }

        rtn = 0;
    } while(0);

    return( rtn );
} // End proc cSplineList::read

//-----------------------------------------------------------------------------
// Name   : cSplineList::write
// Usage  : Write cSplineList to file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         h                X   X   File handler
//         
// Return : 0 == OK / -1 == write error / -2 == id error / -3 == memory error
//-----------------------------------------------------------------------------
int cSplineList::write( FILE * h )
{
    int rtn = -1;

    do {
#if 0
// #ifdef WITH_FO2_DBG
        printf( "++> Writing cSplineList "
                "dwStart=0x%08x dwEnd=0x%08x "
                "AI_SPLINES_START=0x%08x AI_SPLINES_END=0x%08x\n",
                dwStart, dwEnd, AI_SPLINES_START, AI_SPLINES_END );
#endif // WITH_FO2_DBG

        if( AI_SPLINES_START != dwStart ||
            AI_SPLINES_END   != dwEnd )        { rtn = -2; break; }
        if( dwNPoints != splinePoints.size() ) { rtn = -3; break; }

        if( 1 != fwrite( &dwStart, sizeof(dwStart), 1, h )) break;
        if( 1 != fwrite( &dwNPoints, sizeof(dwNPoints), 1, h )) break;

        if( dwNPoints ) {
            rtn = 0;
            for( uint i = 0; 0 == rtn && i < dwNPoints; ++i ) {
                rtn = splinePoints[i].write( h );
            } // End for
            if( 0 != rtn ) break;
        } // End if

        if( 1 != fwrite( dwUnknown,  sizeof(dwUnknown),  1, h ) ||
            1 != fwrite( &dwEnd,     sizeof(dwEnd),      1, h )) {
            rtn = -1;
            break;
        }

        rtn = 0;
    } while(0);

    return( rtn );
} // End proc cSplineList::write

//-----------------------------------------------------------------------------
// Name   : cSplineList::writeBEDfile
// Usage  : Write cSplineList to BED file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         h                X   X   File handler
//         idx              X   -   Spline index
//         
// Return : 0 == OK / -1 == write error / -2 == id error / -3 == memory error
//-----------------------------------------------------------------------------
int cSplineList::writeBEDfile( FILE * h, const uint idx )
{
    int rtn = -1;
    uint i = 0;

    do {
        if( AI_SPLINES_START != dwStart ||
            AI_SPLINES_END   != dwEnd )        { rtn = -2; break; }
        if( dwNPoints != splinePoints.size() ) { rtn = -3; break; }

        if( dwNPoints ) {
            // -- Left border
            if( fprintf( h,
                         "\t[\"AIBorderLineLeft" ) <= 0 ) break;
            if( idx ) {
                if( fprintf( h, "%d", (idx+1) ) <= 0 ) break;
            }

            if( fprintf( h,
                         "\"] = {\n"
                         "\t\tCount = %d,\n"
                         "\t\tControlPoints = {\n", dwNPoints ) <= 0 ) break;

            for( i = 0; i < dwNPoints; ++i ) {
                if( fprintf(h, "\t\t\t[%d] = { %f, %f, %f },\n", (i+1),
                            splinePoints[i].p[AI_BORDER_LEFT].x,
                            splinePoints[i].p[AI_BORDER_LEFT].z,
                            splinePoints[i].p[AI_BORDER_LEFT].y ) <= 0) break;
            } // End for
            if( i != dwNPoints ) break;

            if( fprintf( h,
                         "\t\t},\n"
                         "\t},\n\n" ) <= 0 ) break;

            // -- Right border
            if( fprintf( h,
                         "\t[\"AIBorderLineRight" ) <= 0 ) break;
            if( idx ) {
                if( fprintf( h, "%d", (idx+1) ) <= 0 ) break;
            }

            if( fprintf( h,
                         "\"] = {\n"
                         "\t\tCount = %d,\n"
                         "\t\tControlPoints = {\n", dwNPoints ) <= 0 ) break;

            for( i = 0; i < dwNPoints; ++i ) {
                if( fprintf(h, "\t\t\t[%d] = { %f, %f, %f },\n", (i+1),
                            splinePoints[i].p[AI_BORDER_RIGHT].x,
                            splinePoints[i].p[AI_BORDER_RIGHT].z,
                            splinePoints[i].p[AI_BORDER_RIGHT].y ) <= 0) break;
            } // End for
            if( i != dwNPoints ) break;

            if( fprintf( h,
                         "\t\t},\n"
                         "\t},\n\n" ) <= 0 ) break;

            // -- Race line
            if( splinePoints[0]._raceLine ) { // Skip if not in Blender...
                if( fprintf( h,
                             "\t[\"AIRaceLine" ) <= 0 ) break;
                if( idx ) {
                    if( fprintf( h, "%d", (idx+1) ) <= 0 ) break;
                }

                if( fprintf(h,
                            "\"] = {\n"
                            "\t\tCount = %d,\n"
                            "\t\tControlPoints = {\n", dwNPoints ) <= 0) break;

                for( i = 0; i < dwNPoints; ++i ) {
                    if(fprintf(h, "\t\t\t[%d] = { %f, %f, %f },\n", (i+1),
                               splinePoints[i].p[AI_RACE_LINE].x,
                               splinePoints[i].p[AI_RACE_LINE].z,
                               splinePoints[i].p[AI_RACE_LINE].y ) <= 0) break;
                } // End for
                if( i != dwNPoints ) break;

                if( fprintf( h,
                             "\t\t},\n"
                             "\t},\n\n" ) <= 0 ) break;
            } // End if
        } // End if

        rtn = 0;
    } while(0);

    return( rtn );
} // End proc cSplineList::writeBEDfile

#if !defined(NO_BLENDER)
//-----------------------------------------------------------------------------
// Name   : cSplineList::toBlender
// Usage  : Draw in Blender
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         idx              X   -   (Optional) Index of splineList
//         
// Return : Nothing
//-----------------------------------------------------------------------------
void cSplineList::toBlender( const uint idx )
{
    char name[64];
    vector<BPoint> points;
    BPoint p;
    Object *ob = NULL;

    memset( &p, 0, sizeof(p) );

    points.reserve( dwNPoints );
    for( uint i = 0; i < 5; ++i ) {
        if( i != AI_BORDER_LEFT &&
            i != AI_BORDER_RIGHT &&
            i != AI_RACE_LINE ) continue;

        points.clear();

        for( uint n = 0; n < dwNPoints; ++n ) {
            p.vec[0] = splinePoints[n].p[i].x;
            p.vec[1] = splinePoints[n].p[i].y;
            p.vec[2] = splinePoints[n].p[i].z;
            p.vec[3] = 1.0;
            p.f1 = 1;
            points.push_back(p);
        }

        switch( i ) {
        case AI_BORDER_LEFT: {
            snprintf( name, sizeof(name), "AI_Border_Left_%d", idx );
            break;
        }
        case AI_BORDER_RIGHT: {
            snprintf( name, sizeof(name), "AI_Border_Right_%d", idx );
            break;
        }
        case AI_RACE_LINE: {
            snprintf( name, sizeof(name), "AI_Race_Line_%d", idx );
            break;
        }   
        } // End switch
        ob = addCurve( points, name, ( 0 == idx ) );
        if( ob ) sendToLayer( ob, LAYER_SPLINES );
    } // End for

} // End proc cSplineList::toBlender
#endif // NO_BLENDER

#if !defined(NO_BLENDER)
//-----------------------------------------------------------------------------
// Name   : cSplineList::fromBlender
// Usage  : Get data from Blender
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         idx              X   -   Index of splineList in list
//         
// Return : 0 == OK / -1 == write error / -2 == id error / -3 == memory error
//                    -4 == point count error / -5 == not found
//-----------------------------------------------------------------------------
int cSplineList::fromBlender( const uint idx )
{
    int rtn = 0;
    cSplinePoints spPt;
    Object *ob = NULL;
    Curve  *cu= NULL;
    Nurb   *nu = NULL;
    char name[64];
    uint i,j;
    float vec[4]; // For point transformation

    vec[3] = 0.0;

    // Note: same code in cBorderList::fromBlender
    do {
        splinePoints.clear(); dwNPoints = 0;

        // --------------------------------------------------------
        snprintf( name, sizeof(name), "AI_Border_Left_%d", idx );
        cu = findCurve( name, &ob );
        if( cu ) nu = (Nurb*)cu->nurb.first;
        if( !cu || !nu ) {
            rtn = -5;
            break;
        }

        splinePoints.reserve( nu->pntsu );
        if( splinePoints.capacity() < (uint)nu->pntsu ) {
            rtn = -3;
            break;
        }

        for( i = 0; i < (uint)nu->pntsu; ++i ) {
            spPt.dwNextIdx = ( i != (uint)(nu->pntsu-1) ? (i+1) : 0 );
            spPt.dwZero1   = spPt.dwZero1 = 0;
            spPt.dwPrevIdx = ( i ? i-1 : (nu->pntsu-1) );
            spPt.m2.m[0][0] = spPt.m2.m[1][1] = spPt.m2.m[2][2] = 1.0;

            // Apply object transformations
            for( j = 0; j < 3; ++j ) vec[j] = nu->bp[i].vec[j];
            MTC_Mat4MulVecfl( ob->obmat, vec );
            spPt.p[AI_BORDER_LEFT].x = vec[0];
            spPt.p[AI_BORDER_LEFT].y = vec[1];
            spPt.p[AI_BORDER_LEFT].z = vec[2];

            // ----- Rotation matrix
            float angle;     // Vector angle (rad, signed)
            float vx, vy;    // Vector to next point in spline
            float atan2_v0;  // atan2() of reference vector (0,1)

            atan2_v0 = atan2( 1.0, 0.0 );
            if( i != (uint)(nu->pntsu-1) ) {
                vx = nu->bp[i+1].vec[0] - nu->bp[i].vec[0];
                vy = nu->bp[i+1].vec[1] - nu->bp[i].vec[1];
            } else {
                vx = nu->bp[0].vec[0] - nu->bp[i].vec[0];
                vy = nu->bp[0].vec[1] - nu->bp[i].vec[1];
            }
            angle = atan2( vy, vx ) - atan2_v0;

			float e[3];
			e[0] = e[2] = 0.0;
			e[1] = angle;
			EulToMat3( e, spPt.m1.m );

            splinePoints.push_back( spPt );
        } // End for

        // --------------------------------------------------------

        snprintf( name, sizeof(name), "AI_Border_Right_%d", idx );
        cu = findCurve( name, &ob );
        if( cu ) nu = (Nurb*)cu->nurb.first;
        if( !cu || !nu ) {
            rtn = -2;
            break;
        }

        if( splinePoints.size() != (uint)nu->pntsu ) {
            rtn = -4;
            break;
        }

        for( i = 0; i < (uint)nu->pntsu; ++i ) {
            // Apply object transformations
            for( j = 0; j < 3; ++j ) vec[j] = nu->bp[i].vec[j];
            MTC_Mat4MulVecfl( ob->obmat, vec );
            splinePoints[i].p[AI_BORDER_RIGHT].x = vec[0];
            splinePoints[i].p[AI_BORDER_RIGHT].y = vec[1];
            splinePoints[i].p[AI_BORDER_RIGHT].z = vec[2];
        } // End for

        // --------------------------------------------------------
        snprintf( name, sizeof(name), "AI_Race_Line_%d", idx );
        cu = findCurve( name, &ob );
        if( cu ) { 
            nu = (Nurb*)cu->nurb.first;
            if( !cu || !nu ) {
                rtn = -2;
                break;
            }

            if( splinePoints.size() != (uint)nu->pntsu ) {
                rtn = -4;
                break;
            }

            for( i = 0; i < (uint)nu->pntsu; ++i ) {
                splinePoints[i]._raceLine = 1;

                // Apply object transformations
                for( j = 0; j < 3; ++j ) vec[j] = nu->bp[i].vec[j];
                MTC_Mat4MulVecfl( ob->obmat, vec );
                splinePoints[i].p[AI_RACE_LINE].x = vec[0];
                splinePoints[i].p[AI_RACE_LINE].y = vec[1];
                splinePoints[i].p[AI_RACE_LINE].z = vec[2];
            } // End for

        } else {

            // No race line: use middle of left,right border
            for( i = 0; i < splinePoints.size(); ++i ) {
                splinePoints[i]._raceLine = 0;

                splinePoints[i].p[AI_RACE_LINE].x =
                    ( splinePoints[i].p[AI_BORDER_LEFT].x +
                      splinePoints[i].p[AI_BORDER_RIGHT].x ) / 2;
                splinePoints[i].p[AI_RACE_LINE].y =
                    ( splinePoints[i].p[AI_BORDER_LEFT].y +
                      splinePoints[i].p[AI_BORDER_RIGHT].y ) / 2;
                splinePoints[i].p[AI_RACE_LINE].z =
                    ( splinePoints[i].p[AI_BORDER_LEFT].z +
                      splinePoints[i].p[AI_BORDER_RIGHT].z ) / 2;
            } // End for

        } // End else (cu)


        for( i = 0; i < splinePoints.size(); ++i ) {
            splinePoints[i].p[AI_RACE_LINE_LEFT].x =
                ( splinePoints[i].p[AI_BORDER_LEFT].x +
                  splinePoints[i].p[AI_RACE_LINE].x ) / 2;
            splinePoints[i].p[AI_RACE_LINE_LEFT].y =
                ( splinePoints[i].p[AI_BORDER_LEFT].y +
                  splinePoints[i].p[AI_RACE_LINE].y ) / 2;
            splinePoints[i].p[AI_RACE_LINE_LEFT].z =
                ( splinePoints[i].p[AI_BORDER_LEFT].z +
                  splinePoints[i].p[AI_RACE_LINE].z ) / 2;

            splinePoints[i].p[AI_RACE_LINE_RIGHT].x =
                ( splinePoints[i].p[AI_BORDER_RIGHT].x +
                  splinePoints[i].p[AI_RACE_LINE].x ) / 2;
            splinePoints[i].p[AI_RACE_LINE_RIGHT].y =
                ( splinePoints[i].p[AI_BORDER_RIGHT].y +
                  splinePoints[i].p[AI_RACE_LINE].y ) / 2;
            splinePoints[i].p[AI_RACE_LINE_RIGHT].z =
                ( splinePoints[i].p[AI_BORDER_RIGHT].z +
                  splinePoints[i].p[AI_RACE_LINE].z ) / 2;
            
        } // End for

        dwNPoints = splinePoints.size();  // number of points

#if 0 //def WITH_FO2_DBG
        printf( "dwNPoints=%d size()=%d\n", dwNPoints, splinePoints.size() );
        fflush(stdout );
#endif // WITH_FO2_DBG

        // Set splinePoints values
        uint nxt = 0;
        uint pre = 0;
        float vnorm[2];
        cPoint3D v[2];
        uint b = 0;
        for( i = 0; i < dwNPoints; ++i ) {

#if 0 //def WITH_FO2_DBG
            printf( "Loop #%d : ", i );
            fflush(stdout );
#endif // WITH_FO2_DBG

            nxt = splinePoints[i].dwNextIdx;
            pre = splinePoints[i].dwPrevIdx;

#if 0 //def WITH_FO2_DBG
            printf( "next=%d prev=%d\n", nxt, pre );
            fflush(stdout );
#endif // WITH_FO2_DBG

            // dwUnk1[0]
            vnorm[0] = vnorm[1] = 0.0;
            for( j = 0; j < 2; ++ j ) {
                b = ( 0 == j ? AI_BORDER_LEFT : AI_BORDER_RIGHT );

#if 0 //def WITH_FO2_DBG
                printf( "%d@%d\n", i, __LINE__ );
                fflush(stdout );
#endif // WITH_FO2_DBG
                v[j].x = ( splinePoints[nxt].p[b].x -
                           splinePoints[i].p[b].x );

#if 0 //def WITH_FO2_DBG
                printf( "%d@%d\n", i, __LINE__ );
                fflush(stdout );
#endif // WITH_FO2_DBG
                v[j].y = ( splinePoints[nxt].p[b].y -
                           splinePoints[i].p[b].y );

#if 0 //def WITH_FO2_DBG
                printf( "%d@%d\n", i, __LINE__ );
                fflush(stdout );
#endif // WITH_FO2_DBG
                v[j].z = ( splinePoints[nxt].p[b].z -
                           splinePoints[i].p[b].z );
            } // End for(j)
            for( j = 0; j < 2; ++ j ) {

#if 0 //def WITH_FO2_DBG
                printf( "%d@%d\n", i, __LINE__ );
                fflush(stdout );
#endif // WITH_FO2_DBG
                vnorm[j] = sqrt(v[j].x*v[j].x + v[j].y*v[j].y + v[j].z*v[j].z);
            } // Edn for(j)

#if 0 //def WITH_FO2_DBG
                printf( "%d@%d\n", i, __LINE__ );
                fflush(stdout );
#endif // WITH_FO2_DBG
            splinePoints[i].dwUnk1[0] = ( vnorm[0] + vnorm[1] ) / 2;

            // TODO: dwUnk1[1] ??

            // dwUnk1[2]
#if 0 //def WITH_FO2_DBG
                printf( "%d@%d\n", i, __LINE__ );
                fflush(stdout );
#endif // WITH_FO2_DBG
            splinePoints[i].dwUnk1[2] = ( 0 == i ? 0.0 :
                                          ( splinePoints[pre].dwUnk1[0] +
                                            splinePoints[pre].dwUnk1[2] ));

            // TODO: dwUnk1[3] ??
            // TODO: dwUnk1[4] ??
            // TODO: dwUnk1[5] ??
            // TODO: dwUnk1[6] ??
            
#if 0 //def WITH_FO2_DBG
                printf( "%d@%d\n", i, __LINE__ );
                fflush(stdout );
#endif // WITH_FO2_DBG
            splinePoints[i].dwUnk1[7]  = splinePoints[i].dwUnk1[4];

            // TODO: dwUnk1[8] ??

            splinePoints[i].dwUnk2[0] = i;
            splinePoints[i].dwUnk2[1] = 0;
            splinePoints[i].dwUnk2[2] = 0xffffffff;
            splinePoints[i].dwUnk2[3] = 0;
        } // End for (i)

        dwUnknown[0] = 0; // 1 ???
        dwUnknown[1] = 0x3f000000;
        dwUnknown[2] = 0;
        dwUnknown[3] = 0;
        dwUnknown[4] = 2;

        _index = idx;
    } while(0);

    switch( rtn ) {
    case -2:
        printf( "Cannot find '%s' spline\n", name );
        break;
    case -4:
        printf( "Wrong number of points in '%s' spline\n", name );
        break;
    case -5:
        if( 0 == idx )
            printf( "Cannot find '%s' spline\n", name );
        else
            rtn = 0;
        break;
    }

    return( rtn );
} // End proc cSplineList::fromBlender
#endif // NO_BLENDER

//-----------------------------------------------------------------------------
// Name   : cSplineList::show
// Usage  : Dump cSplineList to screen
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         tab              X   -   (Optional) number of tabs before printing
//         where            X   -   (Optional) where to send data
//         
// Return : Nothing
//-----------------------------------------------------------------------------
void cSplineList::show( const uint tab, FILE *where )
{
    const char * myTab = TABS(tab);
    FILE *out = ( where ? where : stdout );
    uint i = 0;

    fprintf( out,
             "%sSpline List #%d (@ 0x%08x) {\n", myTab, _index, _filePos );
    fprintf(out, "%s\tdwStart   = 0x%08x\n", myTab, dwStart );
    fprintf(out, "%s\tdwNPoints = 0x%08x (%d)\n", myTab, dwNPoints, dwNPoints);
    for( i = 0; i < dwNPoints; ++i ) {
        splinePoints[i].show( tab + 1, where );
    } // End for
    for( i = 0; i < 5; ++i ) {
        fprintf(out, "%s\tdwUnknown[%d] = 0x%08x (%d)\n", myTab, i,
                dwUnknown[i], dwUnknown[i] );
    }
    fprintf(out, "%s\tdwEnd     = 0x%08x\n", myTab, dwEnd );

    fprintf( out, "%s}, -- End Spline List #%d\n", myTab, _index );

    fflush( out );
} // End proc cSplineList::show

//-----------------------------------------------------------------------------
// Name   : cBorder::read
// Usage  : Read cBorder from file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         h                X   X   File handler
//         
// Return : 0 == OK / -1 == read error / -2 == id error
//-----------------------------------------------------------------------------
int  cBorder::read( FILE * h )
{
    int rtn = -1;

    do {
        if( 1 != fread( &dwIndex,  sizeof(dwIndex), 1, h )) break;
        if( 1 != fread( &dwPosIdx, sizeof(dwPosIdx), 1, h ))  break;
        if( 0 != left.read( h ))  break;
        if( 0 != right.read( h )) break;

        rtn = 0;
    } while(0);

    return( rtn );
} // End proc cBorder::read

//-----------------------------------------------------------------------------
// Name   : cBorder::write
// Usage  : Write cBorder to file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         h                X   X   File handler
//         
// Return : 0 == OK / -1 == write error
//-----------------------------------------------------------------------------
int  cBorder::write( FILE * h )
{
    int rtn = -1;

    do {
        if( 1 != fwrite( &dwIndex,  sizeof(dwIndex), 1, h )) break;
        if( 1 != fwrite( &dwPosIdx, sizeof(dwPosIdx), 1, h ))  break;
        if( 0 != left.write( h ))  break;
        if( 0 != right.write( h )) break;

        rtn = 0;
    } while(0);

    return( rtn );
} // End proc cBorder::write

//-----------------------------------------------------------------------------
// Name   : cBorder::show
// Usage  : Dump cBorder to screen
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         tab              X   -   (Optional) number of tabs before printing
//         where            X   -   (Optional) where to send data
//         
// Return : Nothing
//-----------------------------------------------------------------------------
void cBorder::show( const uint tab, FILE *where )
{
    const char * myTab = TABS(tab);
    FILE *out = ( where ? where : stdout );

    fprintf( out, "%s{ -- border\n", myTab );
    fprintf( out, "%s\tdwIndex = 0x%08x (%d)\n", myTab, dwIndex, dwIndex );
    fprintf( out, "%s\tdwPosIdx = 0x%08x (%d)\n", myTab, dwPosIdx, dwPosIdx );
    fprintf( out, "%s\t  (spline=%d idx=%d)\n",   myTab,
             (dwPosIdx >> 24), (dwPosIdx & 0x00FFFFFF));

    fprintf( out, "%s\tleft  = { ", myTab );
    left.show( "", out );
    fprintf( out, "}\n" );

    fprintf( out, "%s\tright = { ", myTab );
    right.show( "", out );
    fprintf( out, "}\n" );
    fprintf( out, "%s} -- border\n", myTab );

    fflush( out );
} // End proc cBorder::show

//-----------------------------------------------------------------------------
// Name   : cBorderList::cBorderList
// Usage  : cBorderList class constructor
// Args   : None
// Return : Nothing
//-----------------------------------------------------------------------------
cBorderList::cBorderList()
{
    dwNBorders = 0;
    dwStart    = AI_BORDER_PT_START;
//     memset( dwUnknown, 0, sizeof(dwUnknown) );
    dwEnd      = AI_BORDER_PT_END;
} // End proc cBorderList::cBorderList

//-----------------------------------------------------------------------------
// Name   : cBorderList::read
// Usage  : Read cBorderList from file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         h                X   X   File handler
//         
// Return : 0 == OK / -1 == read error / -2 == id error / -3 == memory error
//-----------------------------------------------------------------------------
int  cBorderList::read( FILE * h )
{
    int rtn = 0;
    cBorder b;

    do {
        borders.clear();
        if( 1 != fread( &dwNBorders, sizeof(dwNBorders), 1, h )) {
            rtn = -1;
            break;
        }

        if( 1 != fread( &dwStart, sizeof(dwStart), 1, h )) { rtn = -1; break; }
        if( AI_BORDER_PT_START != dwStart ) { rtn = -2; break; }

        if( dwNBorders ) {
            borders.reserve( dwNBorders );
            if( borders.capacity() < dwNBorders ) { rtn = -3; break; }

            rtn = 0;
            for( uint i = 0; 0 == rtn && i < dwNBorders; ++i ) {
                rtn = b.read( h );
                if( 0 == rtn ) borders.push_back( b );
            } // End for
            if( 0 != rtn ) break;
        } // End if

//         if( 1 != fread( dwUnknown,  sizeof(dwUnknown),  1, h )) {
//             rtn = -1;
//             break;
//         }

        if( 1 != fread( &dwEnd, sizeof(dwEnd), 1, h )) break;
        if( AI_BORDER_PT_END != dwEnd ) { rtn = -2; break; }

        rtn = 0;
    } while(0);

    return( rtn );
} // End proc cBorderList::read

//-----------------------------------------------------------------------------
// Name   : cBorderList::write
// Usage  : Write cBorderList to file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         h                X   X   File handler
//         
// Return : 0 == OK / -1 == write error / -2 == id error / -3 == memory error
//-----------------------------------------------------------------------------
int  cBorderList::write( FILE * h )
{
    int rtn = -1;

    do {
        if( AI_BORDER_PT_START != dwStart ||
            AI_BORDER_PT_END   != dwEnd )   { rtn = -2; break; }
        if( dwNBorders != borders.size() )  { rtn = -3; break; }

        if( 1 != fwrite( &dwNBorders, sizeof(dwNBorders), 1, h )) break;
        if( 1 != fwrite( &dwStart, sizeof(dwStart), 1, h )) break;

        if( dwNBorders ) {
            rtn = 0;
            for( uint i = 0; 0 == rtn && i < dwNBorders; ++i ) {
                rtn = borders[i].write( h );
            } // End for
            if( 0 != rtn ) break;
        } // End if

//         if( 1 != fwrite( dwUnknown,  sizeof(dwUnknown),  1, h ) ||
//             1 != fwrite( &dwEnd,     sizeof(dwEnd),      1, h )) {
//             rtn = -1;
//             break;
//         }

        if( 1 != fwrite( &dwEnd, sizeof(dwEnd), 1, h )) break;

        rtn = 0;
    } while(0);

    return( rtn );
} // End proc cBorderList::write

#if !defined(NO_BLENDER)
//-----------------------------------------------------------------------------
// Name   : cBorderList::fromBlender
// Usage  : Get data from Blender
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         idx              X   -   Index of splineList in list
//         
// Return : 0 == OK / -1 == write error / -2 == id error / -3 == memory error
//                    -4 == point count error / -5 == not found
//          1 == end of data
//-----------------------------------------------------------------------------
int cBorderList::fromBlender( const uint idx )
{
    int rtn = 0;
    cBorder b;
    Object *obL = NULL;
    Object *obR = NULL;
    Curve *cu   = NULL;  // Curve pointer
    Nurb  *nuL  = NULL;  // Left curve nurb
    Nurb  *nuR  = NULL;  // Right curve nurb
    char name[64];
    uint i,j;
    float vec[4]; // For point transformation

    vec[3] = 0.0;

    // Note: same code as cSplineList::fromBlender
    do {
        if( 0 == idx ) {
            borders.clear();
            dwNBorders = 0;
        }

        // --------------------------------------------------------
        snprintf( name, sizeof(name), "AI_Border_Left_%d", idx );
        cu = findCurve( name, &obL );
        if( cu ) nuL = (Nurb*)cu->nurb.first;
        if( !cu || !nuL ) {
            rtn = -5;
            break;
        }

        snprintf( name, sizeof(name), "AI_Border_Right_%d", idx );
        cu = findCurve( name, &obR );
        if( cu ) nuR = (Nurb*)cu->nurb.first;
        if( !cu || !nuR ) {
            rtn = -2;
            break;
        }

        if( (uint)nuL->pntsu != (uint)nuR->pntsu ) {
            rtn = -4;
            break;
        }

        if( 0 == idx ) {
            borders.reserve( nuL->pntsu );
            if( borders.capacity() < (uint)nuL->pntsu ) {
                rtn = -3;
                break;
            }
        }

        for( i = 0; i < (uint)nuL->pntsu; ++i ) {
            b.dwIndex  = borders.size();
            b.dwPosIdx = (idx << 24) + i;

            // Apply object transformations
            for( j = 0; j < 3; ++j ) vec[j] = nuL->bp[i].vec[j];
            MTC_Mat4MulVecfl( obL->obmat, vec );
            b.left.x = vec[0];
            b.left.y = vec[1];
            b.left.z = 0.0;

            // Apply object transformations
            for( j = 0; j < 3; ++j ) vec[j] = nuR->bp[i].vec[j];
            MTC_Mat4MulVecfl( obR->obmat, vec );
            b.right.x = vec[0];
            b.right.y = vec[1];
            b.right.z = 0.0;

            borders.push_back( b );
        } // End for
        dwNBorders = borders.size();

    } while(0);

    switch( rtn ) {
    case -2:
        printf( "Cannot find '%s' spline\n", name );
        break;
    case -4:
        printf( "Wrong number of points in '%s' spline\n", name );
        break;
    case -5:
        if( 0 == idx )
            printf( "Cannot find '%s' spline\n", name );
        else
            rtn = 1;
        break;
    }

    return( rtn );
} // End proc cBorderList::fromBlender
#endif // NO_BLENDER

//-----------------------------------------------------------------------------
// Name   : cBorderList::show
// Usage  : Dump cBorderList to screen
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         tab              X   -   (Optional) number of tabs before printing
//         where            X   -   (Optional) where to send data
//         
// Return : Nothing
//-----------------------------------------------------------------------------
void cBorderList::show( const uint tab, FILE *where )
{
    const char * myTab = TABS(tab);
    FILE *out = ( where ? where : stdout );
    uint i = 0;

    fprintf( out,
             "%sBorder = { -- NB borders: %d\n", myTab, dwNBorders );
    fprintf(out, "%s\tdwNBorders = 0x%08x (%d)\n", myTab,
            dwNBorders, dwNBorders);
    fprintf(out, "%s\tdwStart    = 0x%08x\n", myTab, dwStart );
    for( i = 0; i < dwNBorders; ++i ) {
        borders[i].show( tab + 1, where );
    } // End for
//     for( i = 0; i < 5; ++i ) {
//         fprintf(out, "%s\tdwUnknown[%d] = 0x%08x (%d)\n", myTab,
//                 dwUnknown[i], dwUnknown[i] );
//     }
    fprintf(out, "%s\tdwEnd     = 0x%08x\n", myTab, dwEnd );

    fprintf( out, "%s}, -- End Border\n", myTab );

    fflush( out );
} // End proc cBorderList::show

//-----------------------------------------------------------------------------
// Name   : cStartPt::read
// Usage  : Read cStartPt from file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         h                X   X   File handler
//         
// Return : 0 == OK / -1 == read error
//-----------------------------------------------------------------------------
int  cStartPt::read( FILE * h )
{
    int rtn = -1;

    do {
        if( 0 != pos.read( h )) break;
        if( 0 != m.read( h ))   break;

        rtn = 0;
    } while(0);

    return( rtn );
} // End proc cStartPt::read

//-----------------------------------------------------------------------------
// Name   : cStartPt::write
// Usage  : Write cStartPt to file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         h                X   X   File handler
//         
// Return : 0 == OK / -1 == write error
//-----------------------------------------------------------------------------
int  cStartPt::write( FILE * h )
{
    int rtn = -1;

    do {
        if( 0 != pos.write( h )) break;
        if( 0 != m.write( h ))   break;

        rtn = 0;
    } while(0);

    return( rtn );
} // End proc cStartPt::write

#if !defined(NO_BLENDER)
//-----------------------------------------------------------------------------
// Name   : cStartPt::toBlender
// Usage  : Draw in Blender
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         idx              X   -   Car  index
//         
// Return : Nothing
//-----------------------------------------------------------------------------
void cStartPt::toBlender( const uint idx )
{
    char name[64];

    // Code from make_mesh() / python/api2_2x/meshPrimitive.c
    float cent[3] = {0,0,0};
    float imat[3][3]={{1,0,0},{0,1,0},{0,0,1}};
    Mesh *me;
    Object *ob;
    Base *base;

    /* remember active object (if any) for later, so we can re-activate */
    base = BASACT;

    /* make a new object, "copy" to the editMesh structure */
    ob = add_object(OB_MESH);
    me = (Mesh *)ob->data;
    G.obedit = BASACT->object;
    make_editMesh( );

    /* create the primitive in the edit mesh */
    make_prim( 14, imat,	/* mesh type, transform matrix */
               0, 0, 			/* total vertices, segments */
               0, 			/* subdivisions (for Icosphere only) */
               0.0, 0.0,		/* diameter-ish, height */
               0, 0, 			/* extrude, fill end faces */
               cent );				/* location of center */

    /* copy primitive back to the real mesh */
    load_editMesh( );
    free_editMesh( G.editMesh );
    G.obedit = NULL;

    /* if there was an active object, reactivate it */
    if( base )
        scene_select_base(G.scene, base);

    snprintf( name, sizeof(name), "AI_Start_Pos_%d", idx );
    rename_id( &ob->id, name );
    snprintf( name, sizeof(name), "AI_Start_Car_%d", idx );
    rename_id( &me->id, name );

    /* Move and rotate object */
    ob->loc[0] = pos.x;
    ob->loc[1] = pos.y;
    ob->loc[2] = pos.z;

    // Rotate object
	Mat3ToEul( m.m, ob->rot );

    sendToLayer( ob, LAYER_AI_DATA );
} // End proc cStartPt::toBlender
#endif // NO_BLENDER

//-----------------------------------------------------------------------------
// Name   : cStartPt::show
// Usage  : Dump cStartPt to screen
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         tab              X   -   (Optional) number of tabs before printing
//         where            X   -   (Optional) where to send data
//         
// Return : Nothing
//-----------------------------------------------------------------------------
void cStartPt::show( const uint tab, FILE *where )
{
    const char * myTab = TABS(tab);
    FILE *out = ( where ? where : stdout );

    fprintf( out, "%s{ -- startPoint\n", myTab );

    fprintf( out, "%s\tpos  = { ", myTab );
    pos.show( "", out );
    fprintf( out, "}\n" );

    fprintf( out, "%s\tm    = { ", myTab );
    m.show( tab+1, out );
    fprintf( out, "}\n" );

    fprintf( out, "%s} -- startPoint\n", myTab );

    fflush( out );
} // End proc cStartPt::show

//-----------------------------------------------------------------------------
// Name   : cStartPtList::cStartPtList
// Usage  : cStartPtList class constructor
// Args   : None
// Return : Nothing
//-----------------------------------------------------------------------------
cStartPtList::cStartPtList()
{
    dwNStartPt = 0;
    dwStart    = AI_START_PT_START;
    dwEnd      = AI_START_PT_END;
} // End proc cStartPtList::cStartPtList

//-----------------------------------------------------------------------------
// Name   : cStartPtList::read
// Usage  : Read cStartPtList from file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         h                X   X   File handler
//         
// Return : 0 == OK / -1 == read error / -2 == id error / -3 == memory error
//-----------------------------------------------------------------------------
int  cStartPtList::read( FILE * h )
{
    int rtn = 0;
    cStartPt s;

    do {
        if( 1 != fread( &dwStart, sizeof(dwStart), 1, h )) { rtn = -1; break; }
        if( AI_START_PT_START != dwStart ) { rtn = -2; break; }

        if( 1 != fread( &dwNStartPt, sizeof(dwNStartPt), 1, h )) {
            rtn = -1;
            break;
        }

        if( dwNStartPt ) {
            startPt.reserve( dwNStartPt );
            if( startPt.capacity() < dwNStartPt ) { rtn = -3; break; }

            rtn = 0;
            for( uint i = 0; 0 == rtn && i < dwNStartPt; ++i ) {
                rtn = s.read( h );
                if( 0 == rtn ) startPt.push_back( s );
            } // End for
            if( 0 != rtn ) break;
        } // End if

        if( 1 != fread( &dwEnd, sizeof(dwEnd), 1, h )) break;
        if( AI_START_PT_END != dwEnd ) { rtn = -2; break; }

        rtn = 0;
    } while(0);

    return( rtn );
} // End proc cStartPtList::read

//-----------------------------------------------------------------------------
// Name   : cStartPtList::write
// Usage  : Write cStartPtList to file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         h                X   X   File handler
//         
// Return : 0 == OK / -1 == write error / -2 == id error / -3 == memory error
//-----------------------------------------------------------------------------
int  cStartPtList::write( FILE * h )
{
    int rtn = -1;

    do {
        if( AI_START_PT_START != dwStart ||
            AI_START_PT_END   != dwEnd )   { rtn = -2; break; }
        if( dwNStartPt != startPt.size() ) { rtn = -3; break; }

        if( 1 != fwrite( &dwStart, sizeof(dwStart), 1, h )) break;
        if( 1 != fwrite( &dwNStartPt, sizeof(dwNStartPt), 1, h )) break;

        if( dwNStartPt ) {
            rtn = 0;
            for( uint i = 0; 0 == rtn && i < dwNStartPt; ++i ) {
                rtn = startPt[i].write( h );
            } // End for
            if( 0 != rtn ) break;
        } // End if

        if( 1 != fwrite( &dwEnd, sizeof(dwEnd), 1, h )) break;

        rtn = 0;
    } while(0);

    return( rtn );
} // End proc cStartPtList::write

//-----------------------------------------------------------------------------
// Name   : cStartPtList::writeBEDfile
// Usage  : Write cStartPtList to BED file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         h                X   X   File handler
//         
// Return : 0 == OK / -1 == write error / -2 == id error / -3 == memory error
//-----------------------------------------------------------------------------
int  cStartPtList::writeBEDfile( FILE * h )
{
	int rtn = -1;
	uint i = 0;

	do {
		if( AI_START_PT_START != dwStart ||
			AI_START_PT_END   != dwEnd )   { rtn = -2; break; }
		if( dwNStartPt != startPt.size() ) { rtn = -3; break; }

		if( dwNStartPt ) {
			if( fprintf( h, "Count = %d\n\n"
							"Startpoints = {\n", dwNStartPt ) <= 0 ) break;

			for( i = 0; i < dwNStartPt; ++i ) {
				if( fprintf( h,
								"\t[%d] = {\n"
								"\t\tPosition = { %f, %f, %f },\n"
								"\t\tOrientation = {\n"
								"\t\t\t[\"x\"] = { %f, %f, %f },\n"
								"\t\t\t[\"y\"] = { %f, %f, %f },\n"
								"\t\t\t[\"z\"] = { %f, %f, %f },\n"
								"\t\t},\n"
								"\t},\n",
								(i+1),
								startPt[i].pos.x,
								startPt[i].pos.z,
								startPt[i].pos.y,
								// File (FlatOut) : ( a0 b0 c0 )  Internal (Blender) : ( a0 c0 b0 )
								//                  ( a1 b1 c1 )                       ( a2 c2 b2 )
								//                  ( a2 b2 c2 )                       ( a1 c1 b1 )
								startPt[i].m.m[0][0],
								startPt[i].m.m[0][2],
								startPt[i].m.m[0][1],
								startPt[i].m.m[2][0],
								startPt[i].m.m[2][2],
								startPt[i].m.m[2][1],
								startPt[i].m.m[1][0],
								startPt[i].m.m[1][2],
								startPt[i].m.m[1][1] ) <= 0 ) break;
			} // End for
			if( i != dwNStartPt ) break;

			if( fprintf( h, "}\n" ) <= 0 ) break;
		} // End if

		rtn = 0;
	} while(0);

	return( rtn );
} // End proc cStartPtList::writeBEDfile

#if !defined(NO_BLENDER)
//-----------------------------------------------------------------------------
// Name   : cStartPtList::toBlender
// Usage  : Draw in Blender
// Args   : None
//         
// Return : Nothing
//-----------------------------------------------------------------------------
void cStartPtList::toBlender( void )
{
    for( uint i = 0; i < dwNStartPt; ++i ) {
        startPt[i].toBlender(i);
    } // End for
} // End proc cStartPtList::toBlender
#endif // NO_BLENDER

#if !defined(NO_BLENDER)
//-----------------------------------------------------------------------------
// Name   : cStartPtList::fromBlender
// Usage  : Get data from Blender
// Args   : None
//         
// Return : 0 == OK / -1 == write error / -2 == id error / -3 == memory error
//-----------------------------------------------------------------------------
int cStartPtList::fromBlender( void )
{
    int rtn = 0;
    cStartPt sPt;
    char name[64];
    uint i;
    Object *ob = NULL;

    do {
        startPt.clear(); dwNStartPt = 0;

        for( i = 0; 0 == rtn; ++i ) {
            // --------------------------------------------------------
            snprintf( name, sizeof(name), "AI_Start_Pos_%d", i );
            ob = findObject( name );
            if( !ob ) break;

            // Object position
#if 0
            printf( "%s : %f, %f, %f\n",
                    ob->id.name, ob->loc[0], ob->loc[1], ob->loc[2] );
#endif
            sPt.pos.x = ob->loc[0];
            sPt.pos.y = ob->loc[1];
            sPt.pos.z = ob->loc[2];

            // Object rotation
			EulToMat3( ob->rot, sPt.m.m );

            startPt.push_back( sPt );
        } // End for
        if( rtn ) break;
        dwNStartPt = startPt.size();

    } while(0);

    return( rtn );
} // End proc cStartPtList::fromBlender
#endif // NO_BLENDER

//-----------------------------------------------------------------------------
// Name   : cStartPtList::show
// Usage  : Dump cStartPtList to screen
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         tab              X   -   (Optional) number of tabs before printing
//         where            X   -   (Optional) where to send data
//         
// Return : Nothing
//-----------------------------------------------------------------------------
void cStartPtList::show( const uint tab, FILE *where )
{
    const char * myTab = TABS(tab);
    FILE *out = ( where ? where : stdout );
    uint i = 0;

    fprintf( out,
             "%sStart points = { -- NB start points: %d\n", myTab, dwNStartPt);
    fprintf(out, "%s\tdwStart    = 0x%08x\n", myTab, dwStart );
    fprintf(out, "%s\tdwNStartPt = 0x%08x (%d)\n", myTab,
            dwNStartPt, dwNStartPt);
    for( i = 0; i < dwNStartPt; ++i ) {
        startPt[i].show( tab + 1, where );
    } // End for
    fprintf(out, "%s\tdwEnd      = 0x%08x\n", myTab, dwEnd );

    fprintf( out, "%s}, -- End start points\n", myTab );

    fflush( out );
} // End proc cStartPtList::show

//-----------------------------------------------------------------------------
// Name   : cSplitPt::read
// Usage  : Read cSplitPt from file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         h                X   X   File handler
//         
// Return : 0 == OK / -1 == read error
//-----------------------------------------------------------------------------
int  cSplitPt::read( FILE * h )
{
    int rtn = -1;

    do {
        if( 0 != pos.read( h ))   break;
        if( 0 != left.read( h ))  break;
        if( 0 != right.read( h )) break;

        rtn = 0;
    } while(0);

    return( rtn );
} // End proc cSplitPt::read

//-----------------------------------------------------------------------------
// Name   : cSplitPt::write
// Usage  : Write cSplitPt to file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         h                X   X   File handler
//         
// Return : 0 == OK / -1 == write error
//-----------------------------------------------------------------------------
int  cSplitPt::write( FILE * h )
{
    int rtn = -1;

    do {
        if( 0 != pos.write( h ))   break;
        if( 0 != left.write( h ))  break;
        if( 0 != right.write( h )) break;

        rtn = 0;
    } while(0);

    return( rtn );
} // End proc cSplitPt::write

//-----------------------------------------------------------------------------
// Name   : cSplitPt::show
// Usage  : Dump cSplitPt to screen
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         tab              X   -   (Optional) number of tabs before printing
//         where            X   -   (Optional) where to send data
//         
// Return : Nothing
//-----------------------------------------------------------------------------
void cSplitPt::show( const uint tab, FILE *where )
{
    const char * myTab = TABS(tab);
    FILE *out = ( where ? where : stdout );

    fprintf( out, "%s{ -- splitPoint\n", myTab );

    fprintf( out, "%s\tpos  = { ", myTab );
    pos.show( "", out );
    fprintf( out, "}\n" );

    fprintf( out, "%s\tleft = { ", myTab );
    left.show( "", out );
    fprintf( out, "}\n" );

    fprintf( out, "%s\tright = { ", myTab );
    right.show( "", out );
    fprintf( out, "}\n" );

    fprintf( out, "%s} -- splitPoint\n", myTab );

    fflush( out );
} // End proc cSplitPt::show

//-----------------------------------------------------------------------------
// Name   : cSplitPtList::cSplitPtList
// Usage  : cSplitPtList class constructor
// Args   : None
// Return : Nothing
//-----------------------------------------------------------------------------
cSplitPtList::cSplitPtList()
{
    dwNSplitPt = 0;
    dwStart    = AI_SPLIT_PT_START;
    dwEnd      = AI_SPLIT_PT_END;
} // End proc cSplitPtList::cSplitPtList

//-----------------------------------------------------------------------------
// Name   : cSplitPtList::read
// Usage  : Read cSplitPtList from file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         h                X   X   File handler
//         
// Return : 0 == OK / -1 == read error / -2 == id error / -3 == memory error
//-----------------------------------------------------------------------------
int  cSplitPtList::read( FILE * h )
{
    int rtn = 0;
    cSplitPt s;

    do {
        if( 1 != fread( &dwStart, sizeof(dwStart), 1, h )) { rtn = -1; break; }
        if( AI_SPLIT_PT_START != dwStart ) { rtn = -2; break; }

        if( 1 != fread( &dwNSplitPt, sizeof(dwNSplitPt), 1, h )) {
            rtn = -1;
            break;
        }

        if( dwNSplitPt ) {
            splitPt.reserve( dwNSplitPt );
            if( splitPt.capacity() < dwNSplitPt ) { rtn = -3; break; }

            rtn = 0;
            for( uint i = 0; 0 == rtn && i < dwNSplitPt; ++i ) {
                rtn = s.read( h );
                if( 0 == rtn ) splitPt.push_back( s );
            } // End for
            if( 0 != rtn ) break;
        } // End if

        if( 1 != fread( &dwEnd, sizeof(dwEnd), 1, h )) break;
        if( AI_SPLIT_PT_END != dwEnd ) { rtn = -2; break; }

        rtn = 0;
    } while(0);

    return( rtn );
} // End proc cSplitPtList::read

//-----------------------------------------------------------------------------
// Name   : cSplitPtList::write
// Usage  : Write cSplitPtList to file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         h                X   X   File handler
//         
// Return : 0 == OK / -1 == write error / -2 == id error / -3 == memory error
//-----------------------------------------------------------------------------
int  cSplitPtList::write( FILE * h )
{
    int rtn = -1;

    do {
        if( AI_SPLIT_PT_START != dwStart ||
            AI_SPLIT_PT_END   != dwEnd )   { rtn = -2; break; }
        if( dwNSplitPt != splitPt.size() ) { rtn = -3; break; }

        if( 1 != fwrite( &dwStart, sizeof(dwStart), 1, h )) break;
        if( 1 != fwrite( &dwNSplitPt, sizeof(dwNSplitPt), 1, h )) break;

        if( dwNSplitPt ) {
            rtn = 0;
            for( uint i = 0; 0 == rtn && i < dwNSplitPt; ++i ) {
                rtn = splitPt[i].write( h );
            } // End for
            if( 0 != rtn ) break;
        } // End if

        if( 1 != fwrite( &dwEnd, sizeof(dwEnd), 1, h )) break;

        rtn = 0;
    } while(0);

    return( rtn );
} // End proc cSplitPtList::write

//-----------------------------------------------------------------------------
// Name   : cSplitPtList::writeBEDfile
// Usage  : Write cSplitPtList to BED file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         h                X   X   File handler
//         
// Return : 0 == OK / -1 == write error / -2 == id error / -3 == memory error
//-----------------------------------------------------------------------------
int  cSplitPtList::writeBEDfile( FILE * h )
{
    int rtn = -1;
    uint i = 0;

    do {
        if( AI_SPLIT_PT_START != dwStart ||
            AI_SPLIT_PT_END   != dwEnd )   { rtn = -2; break; }
        if( dwNSplitPt != splitPt.size() ) { rtn = -3; break; }

        if( dwNSplitPt ) {
            if( fprintf( h, "Count = %d\n\n"
                         "Splitpoints = {\n", dwNSplitPt ) <= 0 ) break;

            for( i = 0; i < dwNSplitPt; ++i ) {
                if( fprintf( h,
                             "\t[%d] = {\n"
                             "\t\tPosition = { %f, %f, %f },\n"
                             "\t\tLeft     = { %f, %f, %f },\n"
                             "\t\tRight    = { %f, %f, %f },\n"
                             "\t},\n",
                             (i+1),
                             splitPt[i].pos.x,
                             0.0, //splitPt[i].pos.z,
                             splitPt[i].pos.y,
                             splitPt[i].left.x,
                             0.0, //splitPt[i].left.z,
                             splitPt[i].left.y,
                             splitPt[i].right.x,
                             0.0, //splitPt[i].right.z,
                             splitPt[i].right.y ) <= 0 ) break;
            } // End for
            if( i != dwNSplitPt ) break;

            if( fprintf( h, "}\n" ) <= 0 ) break;
        } // End if

        rtn = 0;
    } while(0);

    return( rtn );
} // End proc cSplitPtList::writeBEDfile

#if !defined(NO_BLENDER)
//-----------------------------------------------------------------------------
// Name   : cSplitPtList::toBlender
// Usage  : Draw in Blender
// Args   : None
//         
// Return : Nothing
//-----------------------------------------------------------------------------
void cSplitPtList::toBlender( void )
{
    char name[64];
    vector<BPoint> points;
    BPoint p;
    Object *ob = NULL;

    memset( &p, 0, sizeof(p) );

    points.reserve( 3 );
    for( uint i = 0; i < dwNSplitPt; ++i ) {
        points.clear();
        p.vec[3] = 1.0;
        p.f1 = 1;

        // Always left to right !!
        p.vec[0] = splitPt[i].left.x;
        p.vec[1] = splitPt[i].left.y;
        p.vec[2] = splitPt[i].left.z;
        points.push_back(p);

        p.vec[0] = splitPt[i].pos.x;
        p.vec[1] = splitPt[i].pos.y;
        p.vec[2] = splitPt[i].pos.z;
        points.push_back(p);

        p.vec[0] = splitPt[i].right.x;
        p.vec[1] = splitPt[i].right.y;
        p.vec[2] = splitPt[i].right.z;
        points.push_back(p);

        snprintf( name, sizeof(name), "AI_Split_Point_%d", i );

        ob = addCurve( points, name, 0 );
        if( ob ) sendToLayer( ob, LAYER_AI_DATA );
    } // End for
} // End proc cSplitPtList::toBlender
#endif // NO_BLENDER

#if !defined(NO_BLENDER)
//-----------------------------------------------------------------------------
// Name   : cSplitPtList::fromBlender
// Usage  : Get data from Blender
// Args   : None
//         
// Return : 0 == OK / -1 == write error / -2 == id error / -3 == memory error
//                    -4 == bad point count error
//-----------------------------------------------------------------------------
int cSplitPtList::fromBlender( void )
{
    int rtn = 0;
    cSplitPt sPt;
    Object *ob = NULL;
    Curve *cu  = NULL;
    Nurb  *nu  = NULL;
    char name[64];
    uint i;

    do {
        splitPt.clear(); dwNSplitPt = 0;

        for( i = 0; 0 == rtn; ++i ) {
            // --------------------------------------------------------
            snprintf( name, sizeof(name), "AI_Split_Point_%d", i );
            cu = findCurve( name, &ob );
            if( !cu ) break;

            nu = (Nurb*)cu->nurb.first;
            if( !nu ) {
                rtn = -3;
                break;
            }

            if( AI_NB_POINTS_IN_SPLITPT_CURVE != (uint)nu->pntsu ) {
                rtn = -4;
                break;
            }

            // Always left to right !!
            sPt.left.x = nu->bp[0].vec[0];
            sPt.left.y = nu->bp[0].vec[1];
            sPt.left.z = nu->bp[0].vec[2];

            sPt.pos.x = nu->bp[1].vec[0];
            sPt.pos.y = nu->bp[1].vec[1];
            sPt.pos.z = nu->bp[1].vec[2];

            sPt.right.x = nu->bp[2].vec[0];
            sPt.right.y = nu->bp[2].vec[1];
            sPt.right.z = nu->bp[2].vec[2];

            splitPt.push_back( sPt );
        } // End for
        if( rtn ) break;
        dwNSplitPt = splitPt.size();

    } while(0);

    switch( rtn ) {
    case -3:
        printf( "Cannot find curve for '%s' split line\n", name );
        break;
    case -4:
        printf( "Wrong number of points in '%s' split line\n", name );
        break;
    }

    return( rtn );
} // End proc cSplitPtList::fromBlender
#endif // NO_BLENDER

//-----------------------------------------------------------------------------
// Name   : cSplitPtList::show
// Usage  : Dump cSplitPtList to screen
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         tab              X   -   (Optional) number of tabs before printing
//         where            X   -   (Optional) where to send data
//         
// Return : Nothing
//-----------------------------------------------------------------------------
void cSplitPtList::show( const uint tab, FILE *where )
{
    const char * myTab = TABS(tab);
    FILE *out = ( where ? where : stdout );
    uint i = 0;

    fprintf( out,
             "%sSplit points = { -- NB split points: %d\n", myTab, dwNSplitPt);
    fprintf(out, "%s\tdwStart    = 0x%08x\n", myTab, dwStart );
    fprintf(out, "%s\tdwNSplitPt = 0x%08x (%d)\n", myTab,
            dwNSplitPt, dwNSplitPt);
    for( i = 0; i < dwNSplitPt; ++i ) {
        splitPt[i].show( tab + 1, where );
    } // End for
    fprintf(out, "%s\tdwEnd      = 0x%08x\n", myTab, dwEnd );

    fprintf( out, "%s}, -- End split points\n", myTab );

    fflush( out );
} // End proc cSplitPtList::show

//-----------------------------------------------------------------------------
// Name   : cAIunknown::read
// Usage  : Read cAIunknown from file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         h                X   X   File handler
//         
// Return : 0 == OK / -1 == read error
//-----------------------------------------------------------------------------
int  cAIunknown::read( FILE * h )
{
    int rtn = -1;

#ifdef WITH_FO2_DBG
//     printf( "\tEntering cAIunknown::read()\n" );
#endif // WITH_FO2_DBG

    do {
        if( 1 != fread( &dwUnk1, sizeof(dwUnk1), 1, h ) ||
            1 != fread( &dwUnk2, sizeof(dwUnk2), 1, h )) break;

        rtn = 0;
    } while(0);

#ifdef WITH_FO2_DBG
//     printf( "\tExiting cAIunknown::read() rtn=%d\n", rtn );
#endif // WITH_FO2_DBG

    return( rtn );
} // End proc cAIunknown::read

//-----------------------------------------------------------------------------
// Name   : cAIunknown::write
// Usage  : Write cAIunknown from file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         h                X   X   File handler
//         
// Return : 0 == OK / -1 == read error
//-----------------------------------------------------------------------------
int  cAIunknown::write( FILE * h )
{
    int rtn = -1;

    do {
        if( 1 != fwrite( &dwUnk1, sizeof(dwUnk1), 1, h ) ||
            1 != fwrite( &dwUnk2, sizeof(dwUnk2), 1, h )) break;

        rtn = 0;
    } while(0);

    return( rtn );
} // End proc cAIunknown::write

//-----------------------------------------------------------------------------
// Name   : cAIunknown::show
// Usage  : Dump cAIunknown to screen
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         tab              X   -   (Optional) number of tabs before printing
//         where            X   -   (Optional) where to send data
//         
// Return : Nothing
//-----------------------------------------------------------------------------
void cAIunknown::show( const uint tab, FILE *where )
{
    const char * myTab = TABS(tab);
    FILE *out = ( where ? where : stdout );

    fprintf( out, "%s{\n", myTab );
    fprintf( out, "%s\tdwUnk1 = 0x%08x (%d)\n", myTab, dwUnk1, dwUnk1 );
    fprintf( out, "%s\tdwUnk2 = 0x%08x (%d)\n", myTab, dwUnk2, dwUnk2 );
    fprintf( out, "%s}\n", myTab );

    fflush( out );
} // End proc cAIunknown::show

//-----------------------------------------------------------------------------
// Name   : cAIunknownList::cAIunknownList
// Usage  : cAIunknownList class constructor
// Args   : None
// Return : Nothing
//-----------------------------------------------------------------------------
cAIunknownList::cAIunknownList()
{
    dwNUnk  = 0;
    dwStart = AI_UNKNOWN_START;
    dwEnd   = AI_UNKNOWN_END;
} // End proc cAIunknownList::cAIunknownList

//-----------------------------------------------------------------------------
// Name   : cAIunknownList::read
// Usage  : Read cAIunknownList from file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         h                X   X   File handler
//         
// Return : 0 == OK / -1 == read error / -2 == id error / -3 == memory error
//-----------------------------------------------------------------------------
int  cAIunknownList::read( FILE * h )
{
    int rtn = 0;
    cAIunknown u;

#ifdef WITH_FO2_DBG
//     printf( "Entering cAIunknownList::read()\n" );
#endif // WITH_FO2_DBG

    do {
        unknowns.clear();

        if( 1 != fread( &dwNUnk, sizeof(dwNUnk), 1, h )) {
            rtn = -1;
            break;
        }

#ifdef WITH_FO2_DBG
//         printf( " => dwNUnk=%d\n", dwNUnk );
#endif // WITH_FO2_DBG

        if( 1 != fread( &dwStart, sizeof(dwStart), 1, h )) { rtn = -1; break; }
        if( AI_UNKNOWN_START != dwStart ) { rtn = -2; break; }

        if( dwNUnk ) {
            unknowns.reserve( dwNUnk );
            if( unknowns.capacity() < dwNUnk ) { rtn = -3; break; }

            rtn = 0;
            for( uint i = 0; 0 == rtn && i < dwNUnk; ++i ) {
                rtn = u.read( h );
                if( 0 == rtn ) unknowns.push_back( u );
            } // End for
            if( 0 != rtn ) break;
        } // End if

        if( 1 != fread( &dwEnd, sizeof(dwEnd), 1, h )) break;
        if( AI_UNKNOWN_END != dwEnd ) { rtn = -2; break; }

        rtn = 0;
    } while(0);

    return( rtn );
} // End proc cAIunknownList::read

//-----------------------------------------------------------------------------
// Name   : cAIunknownList::write
// Usage  : Write cAIunknownList to file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         h                X   X   File handler
//         
// Return : 0 == OK / -1 == write error / -2 == id error / -3 == memory error
//-----------------------------------------------------------------------------
int  cAIunknownList::write( FILE * h )
{
    int rtn = -1;

    do {
        if( AI_UNKNOWN_START != dwStart ||
            AI_UNKNOWN_END   != dwEnd )   { rtn = -2; break; }
        if( dwNUnk != unknowns.size() )  { rtn = -3; break; }

        if( 1 != fwrite( &dwNUnk, sizeof(dwNUnk), 1, h )) break;
        if( 1 != fwrite( &dwStart, sizeof(dwStart), 1, h )) break;

        if( dwNUnk ) {
            rtn = 0;
            for( uint i = 0; 0 == rtn && i < dwNUnk; ++i ) {
                rtn = unknowns[i].write( h );
            } // End for
            if( 0 != rtn ) break;
        } // End if

        if( 1 != fwrite( &dwEnd,     sizeof(dwEnd),      1, h )) {
            rtn = -1;
            break;
        }

        rtn = 0;
    } while(0);

    return( rtn );
} // End proc cAIunknownList::write

#if !defined(NO_BLENDER)
//-----------------------------------------------------------------------------
// Name   : cAIunknownList::fromBlender
// Usage  : Get data from Blender
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         nb               X   -   (Optional) number of points
//         
// Return : 0 == OK / -1 == write error / -2 == id error / -3 == memory error
//-----------------------------------------------------------------------------
int cAIunknownList::fromBlender( const uint nb )
{
    int rtn = 0;
    cAIunknown u;
//     uint i;

    do {
        unknowns.clear(); dwNUnk = 0;

#if 0 // TODO: finish me!
        for( i = 1; 0 == rtn && i < nb; i+=1 ) {
            u.dwUnk1 = i;
            u.dwUnk2 = 0;
            
            unknowns.push_back( u );
        }
        dwNUnk = unknowns.size();
#endif 
    } while(0);

    return(rtn);
} // End proc cAIunknownList::fromBlender
#endif // NO_BLENDER

//-----------------------------------------------------------------------------
// Name   : cAIunknownList::show
// Usage  : Dump cAIunknownList to screen
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         tab              X   -   (Optional) number of tabs before printing
//         where            X   -   (Optional) where to send data
//         
// Return : Nothing
//-----------------------------------------------------------------------------
void cAIunknownList::show( const uint tab, FILE *where )
{
    const char * myTab = TABS(tab);
    FILE *out = ( where ? where : stdout );
    uint i = 0;

    fprintf( out,
             "%sAIunknowns = { -- NB unknowns: %d\n", myTab, dwNUnk );
    fprintf(out, "%s\tdwNUnk  = 0x%08x (%d)\n", myTab,
            dwNUnk, dwNUnk);
    fprintf(out, "%s\tdwStart = 0x%08x\n", myTab, dwStart );
    for( i = 0; i < dwNUnk; ++i ) {
        unknowns[i].show( tab + 1, where );
    } // End for
    fprintf(out, "%s\tdwEnd     = 0x%08x\n", myTab, dwEnd );

    fprintf( out, "%s}, -- End AIunknowns\n", myTab );

    fflush( out );
} // End proc cAIunknownList::show


//-----------------------------------------------------------------------------
// Name   : cTrackAI::cTrackAI
// Usage  : cTrackAI class constructor
// Args   : None
// Return : Nothing
//-----------------------------------------------------------------------------
cTrackAI::cTrackAI()
{
    _baseDir      = NULL;
    _logFile      = NULL;
    dwNSplineList = 0;
    dwStart       = AI_FILE_START;
    dwEnd         = AI_FILE_END;
    dwStartPt     = AI_POINT_START;
    dwEndPt       = AI_POINT_END;
    dwStartBd     = AI_BORDERS_START;
    dwEndBd       = AI_BORDERS_END;
} // End proc cTrackAI::cTrackAI

//-----------------------------------------------------------------------------
// Name   : cTrackAI::read
// Usage  : Read cTrackAI from file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         baseDir          X   -   Base directory of track data
//         printOnLoad      X   -   (OPtional) Print data blocks while reading
//         logFile          X   -   (Optional) log file name
//         
// Return : 0 == OK / -1 == read error / -2 == file access error
//                    -3 == memory error
//                    -4 == read data does not match file length
//-----------------------------------------------------------------------------
int cTrackAI::read( const char * const baseDir,
                    const int printOnLoad,
                    const char * const logFile )
{
    char fileName[256];

    FILE *h = NULL;
    int rtn = 0;
    FILE *out = NULL;

    uint fileLength = 0;
    uint filePos    = 0;

    do {
        if( NULL == baseDir ) { errLine = __LINE__; rtn = -1; break; }

        snprintf( fileName, sizeof(fileName), "%s", baseDir );

        snprintf( fileName+strlen(fileName),
                  sizeof(fileName)-strlen(fileName),
                  "%c%s%c%s",
                  DIR_SEP, AI_TRACKAI_DIR, DIR_SEP, AI_TRACKAI_FILE );

        if( logFile ) {
            if( _logFile ) free( _logFile );
            _logFile = strdup( logFile );
        }

// printf( "baseDir : %s\n", baseDir );
// printf( "fileName: %s\n", fileName );
// printf( "logFile : %s\n", logFile );
// printf( "_logFile: %s\n", _logFile );

        if( NULL == ( h = fopen( fileName, "rb" ))) { rtn = -2; break; }

        fseek( h, 0, SEEK_END );
        fileLength = ftell( h );
        fseek( h, 0, SEEK_SET );

        // Check this is a FlatOut2 trackAI file...
        if( 1 != fread( &dwStart,   sizeof(dwStart),   1, h ) ||
            1 != fread( &dwNSplineList, sizeof(dwNSplineList), 1, h ) ||
            AI_FILE_START != dwStart ) {
            rtn = -1;
            break;
        }

        if( printOnLoad && _logFile ) {
            out = fopen( _logFile, "a");
//             if( out ) printf( "Log file: %s\n", _logFile );
        }

        out = (out ? out : stdout);
        if( printOnLoad ) fprintf( out,
                                   "{ -- TrackAI '%s'\n"
                                   "\tdwStart       = 0x%08x\n"
                                   "\tdwNSplineList = %d\n",
                                   fileName, dwStart, dwNSplineList );

        // Read splines
        splineList.reserve( dwNSplineList );
        if( splineList.capacity() < dwNSplineList ) { rtn = -3; break; }

        cSplineList *pSList = NULL;
        for( uint i = 0; 0 == rtn && i < dwNSplineList; ++i ) {
            pSList = new cSplineList(i);
            if( NULL == pSList ) { rtn = -3; break; }

            rtn = pSList->read( h );
            if( printOnLoad ) pSList->show( 1, out );
            if( 0 == rtn ) splineList.push_back( *pSList );
            delete pSList;
        }
        if( rtn ) break;

        if( 1 != fread( &dwStartPt, sizeof(dwStartPt), 1, h ) ||
            AI_POINT_START != dwStartPt ) {
            rtn = -1;
            break;
        }
        if( printOnLoad ) fprintf( out,
                                   "\tdwStartPt = 0x%08x\n", dwStartPt );

        // Read start points
        rtn = startPtList.read( h );
        if( printOnLoad ) startPtList.show( 1, out );
        if( rtn ) break;

        // Read split points
        rtn = splitPtList.read( h );
        if( printOnLoad ) splitPtList.show( 1, out );
        if( rtn ) break;

        if( 1 != fread( &dwEndPt, sizeof(dwEndPt), 1, h ) ||
            AI_POINT_END != dwEndPt ||
            1 != fread( &dwStartBd, sizeof(dwStartBd), 1, h ) ||
            AI_BORDERS_START != dwStartBd) {
            rtn = -1;
            break;
        }
        if( printOnLoad ) fprintf( out,
                                   "\tdwEndPt   = 0x%08x\n"
                                   "\tdwStartBd = 0x%08x\n",
                                   dwEndPt, dwStartBd );

        // Read borders
        rtn = borderList.read( h );
        if( printOnLoad ) borderList.show( 1, out );
        if( rtn ) break;

        // Read unknown
        rtn = unknownList.read( h );
        if( printOnLoad ) unknownList.show( 1, out );
        if( rtn ) break;

        if( 1 != fread( &dwEndBd, sizeof(dwEndBd), 1, h ) ||
            AI_BORDERS_END != dwEndBd ||
            1 != fread( &dwEnd, sizeof(dwEnd), 1, h ) ||
            AI_FILE_END != dwEnd ) {
            rtn = -1;
            break;
        }
        if( printOnLoad ) fprintf( out,
                                   "\tdwEndBd = 0x%08x\n"
                                   "\tdwEnd   = 0x%08x\n",
                                   dwEndBd, dwEnd );

        filePos = ftell(h);
    } while(0);

    if( printOnLoad ) {
        if( 0 == rtn ) {
            fprintf( out,
                     "} -- FilePos = 0x%08x (FileLen = 0x%08x)\n",
                     filePos, fileLength );
        } else {
            fprintf( (out ? out : stdout),
                     "!! ERROR rtn=%d FilePos = 0x%08x!!\n",
                     rtn, ftell(h) );
        }
    }

    if( h ) fclose( h );
    if( out && out != stdout ) fclose( out );

    if( 0 == rtn &&  filePos != fileLength ) rtn = -4;

    return( rtn );
} // End proc cTrackAI::read

//-----------------------------------------------------------------------------
// Name   : cTrackAI::write
// Usage  : Write cTrackAI to file
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         baseDir          X   -   Base directory of track data
//         printOnWrite     X   -   (OPtional) Print data blocks while writing
//         
// Return : 0 == OK / -1 == write error / -2 == file access error
//                    -3 == memory error
//-----------------------------------------------------------------------------
int cTrackAI::write( const char * const baseDir,
                     const int printOnWrite )
{
    char fileName[256];

    FILE *h = NULL;
    int rtn = 0;
    FILE *out = NULL;
    uint i = 0;

#ifdef WITH_FO2_DBG
    char dbgName[256];
    char *c;
#endif // WITH_FO2_DBG

    do {
        if( NULL == baseDir ) { rtn = -1; break; }

        // -------- Write BED files

        // Write splines
        snprintf( fileName, sizeof(fileName),
                  "%s%c%s%c%s", baseDir, DIR_SEP,
                  AI_TRACKAI_DIR, DIR_SEP, AI_SPLINES_BED_FILE );

#ifdef WITH_FO2_DBG
//         printf("--> baseDir=%s\n", baseDir );
//         printf("--> AI_TRACKAI_DIR=%s\n", AI_TRACKAI_DIR );
//         printf("--> AI_SPLINES_BED_FILE=%s\n", AI_SPLINES_BED_FILE );
#endif
        if( NULL == ( h = fopen( fileName, "w" ))) { rtn = -2; break; }

        // Compute splint count (maybe all race lines are not present...)
        uint count = 2*dwNSplineList;
        for( i = 0; i < dwNSplineList; ++i ) {
            if( splineList[i].dwNPoints &&
                splineList[i].splinePoints[0]._raceLine ) count++;
        }
        
        if( fprintf( h, "\n-- %s\n\n", TE_GENERATED ) <= 0 ) break;
        if( fprintf( h, "Count = %d\n\n"
                     "Splines = {\n", count ) <= 0 ) break;

        for( i = 0; 0 == rtn && i < dwNSplineList; ++i ) {
            rtn = splineList[i].writeBEDfile( h, i );
            if( rtn ) { errLine = __LINE__; break; }
        }
        if( rtn ) break;
        if( fprintf( h, "}\n" ) <= 0 ) break;
        fclose( h );

        // Write start points
        snprintf( fileName, sizeof(fileName),
                  "%s%c%s%c%s", baseDir, DIR_SEP,
                  AI_TRACKAI_DIR, DIR_SEP, AI_STARTPT_BED_FILE );

        if( NULL == ( h = fopen( fileName, "w" ))) { rtn = -2; break; }

        if( fprintf( h, "\n-- %s\n\n", TE_GENERATED ) <= 0 ) break;
        rtn = startPtList.writeBEDfile( h );
        fclose( h );
        if( rtn ) { errLine = __LINE__; break; }

        // Write split points
        snprintf( fileName, sizeof(fileName),
                  "%s%c%s%c%s", baseDir, DIR_SEP,
                  AI_TRACKAI_DIR, DIR_SEP, AI_SPLITPT_BED_FILE );

        if( NULL == ( h = fopen( fileName, "w" ))) { rtn = -2; break; }

        if( fprintf( h, "\n-- %s\n\n", TE_GENERATED ) <= 0 ) break;
        rtn = splitPtList.writeBEDfile( h );
        fclose( h );
        if( rtn ) { errLine = __LINE__; break; }

        // -------- Write trackai.bin files

        snprintf( fileName, sizeof(fileName),
                  "%s%c%s%c%s", baseDir, DIR_SEP,
                  AI_TRACKAI_DIR, DIR_SEP, AI_TRACKAI_FILE );

        if( NULL == ( h = fopen( fileName, "wb" ))) { rtn = -2; break; }

        if( printOnWrite && _logFile ) {
            char *c;
            c = strstr( _logFile, FO2_READ_EXT FO2_LOG_EXT ); //TODO: CHANGEME?
            if( c ) sprintf( c, "%s%s", FO2_WRITE_EXT, FO2_LOG_EXT );
            out = fopen( _logFile, "a");
//             if( out ) printf( "Log file: %s\n", _logFile );
        }

#ifdef WITH_FO2_DBG
        if( _logFile ) {
            snprintf( dbgName, sizeof(dbgName), "%s", _logFile );
            c = strstr( dbgName, FO2_LOG_EXT );
            if( c ) sprintf( c, "%s", FO2_DBG_EXT );
            dbg = fopen( dbgName, "a" );
//             if( dbg ) printf( "Dbg file: %s\n", dbgName );
            if( NULL == dbg ) dbg = stdout;

            this->show(0,dbg);
            fflush(dbg);
        }
#endif // WITH_FO2_DBG

        if( printOnWrite ) {
            out = (out ? out : stdout);
            fprintf( out, "{ -- TrackAI '%s'\n", fileName );
        }

        // Check record headers/footers
        if( AI_FILE_START != dwStart ||
            AI_POINT_START != dwStartPt ||
            AI_POINT_END != dwEndPt ||
            AI_BORDERS_START != dwStartBd ||
            AI_BORDERS_END != dwEndBd ||
            AI_FILE_END != dwEnd ) { errLine = __LINE__; break; }
        if( dwNSplineList != splineList.size() )  {
            errLine = __LINE__;
            rtn = -3;
            break;
        }

        // Write header
        if( 1 != fwrite( &dwStart,   sizeof(dwStart),   1, h ) ||
            1 != fwrite( &dwNSplineList, sizeof(dwNSplineList), 1, h )) {
            errLine = __LINE__;
            break;
        }

        // Write splines
        for( i = 0; 0 == rtn && i < dwNSplineList; ++i ) {

#if 0
// #ifdef WITH_FO2_DBG
            fprintf( dbg, "++> Writing splines #%d (dwNSplineList=%d)\n",
                     i , dwNSplineList );
#endif // WITH_FO2_DBG

            rtn = splineList[i].write( h );

#if 0
// #ifdef WITH_FO2_DBG
            fprintf( dbg, "++> Wrote splines #%d (rtn=%d)\n",
                     i , rtn );
#endif // WITH_FO2_DBG

            if( printOnWrite ) splineList[i].show( 1, out );
            if( rtn ) { errLine = __LINE__; break; }
        }
        if( rtn ) break;

        if( 1 != fwrite( &dwStartPt, sizeof(dwStartPt), 1, h )) {
            errLine = __LINE__;
            break;
        }

        // Write start points
        rtn = startPtList.write( h );
        if( printOnWrite ) startPtList.show( 1, out );
        if( rtn ) { errLine = __LINE__; break; }

        // Write split points
        rtn = splitPtList.write( h );
        if( printOnWrite ) splitPtList.show( 1, out );
        if( rtn ) { errLine = __LINE__; break; }

        if( 1 != fwrite( &dwEndPt, sizeof(dwEndPt), 1, h ) ||
            1 != fwrite( &dwStartBd, sizeof(dwStartBd), 1, h ) ) {
            errLine = __LINE__;
            break;
        }

        // Write borders
        rtn = borderList.write( h );
        if( printOnWrite ) borderList.show( 1, out );
        if( rtn ) { errLine = __LINE__; break; }

        // Write unknown
        rtn = unknownList.write( h );
        if( printOnWrite ) unknownList.show( 1, out );
        if( rtn ) { errLine = __LINE__; break; }

        if( 1 != fwrite( &dwEndBd, sizeof(dwEndBd), 1, h ) ) {
            errLine = __LINE__;
            break;
        }

        if( 1 != fwrite( &dwEnd, sizeof(dwEnd), 1, h ) ) {
            errLine = __LINE__;
            break;
        }

    } while(0);

    if( printOnWrite ) {
        if( 0 == rtn ) {
            fprintf( (out ? out : stdout),
                     "} -- FilePos = 0x%08x\n",
                     ftell(h) );
        } else {
            fprintf( (out ? out : stdout),
                     "!! ERROR on line %d (rtn=%d)!!\n", errLine,rtn );
        }
    }

    if( h ) fclose( h );

    if( out && out != stdout ) fclose( out );

#ifdef WITH_FO2_DBG
    if( dbg && dbg != stdout ) fclose(dbg);
#endif // WITH_FO2_DBG

    return( rtn );
} // End proc cTrackAI::write

#if !defined(NO_BLENDER)
//-----------------------------------------------------------------------------
// Name   : cTrackAI::toBlender
// Usage  : Draw in Blender
// Args   : None
//         
// Return : Nothing
//-----------------------------------------------------------------------------
void cTrackAI::toBlender( void )
{
    for( uint i = 0; i < dwNSplineList; ++i ) {
        splineList[i].toBlender( i );
    }

    startPtList.toBlender();
    splitPtList.toBlender();

    borderList.toBlender();
    unknownList.toBlender();
} // End proc cTrackAI::toBlender
#endif // NO_BLENDER

#if !defined(NO_BLENDER)
//-----------------------------------------------------------------------------
// Name   : cTrackAI::fromBlender
// Usage  : Get data from Blender
// Args   : None
//         
// Return : 0 == OK / -1 == write error / -2 == id error / -3 == memory error
//-----------------------------------------------------------------------------
int cTrackAI::fromBlender( void )
{
    int rtn = 0;
    cSplineList spList;

    do {
        splineList.clear(); dwNSplineList = 0;

        for( uint i = 0; 0 == rtn; ++i ) {
            rtn = spList.fromBlender( i );

            if( 0 == rtn ) {
                if( spList.splinePoints.size() ) {
                    splineList.push_back(spList);
                } else {
                    break;
                }
            }
        }
        dwNSplineList = splineList.size();
        if( rtn ) break;

        rtn = startPtList.fromBlender();
        if( rtn ) break;

        rtn = splitPtList.fromBlender();
        if( rtn ) break;

        for( uint i = 0; 0 == rtn; ++i ) {
            rtn = borderList.fromBlender( i );

            if( 1 == rtn ) {
                rtn = 0;
                break;
            }
        }
        if( rtn ) break;

        rtn = unknownList.fromBlender( borderList.dwNBorders/2 );
        if( rtn ) break;

    } while(0);

    return( rtn );
} // End proc cTrackAI::fromBlender
#endif // NO_BLENDER

//-----------------------------------------------------------------------------
// Name   : cTrackAI::show
// Usage  : Dump cTrackAI to screen
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         tab              X   -   (Optionnal) tabulation string
//         where            X   -   (Optional) where to send data
//         
// Return : Nothing
//-----------------------------------------------------------------------------
void cTrackAI::show( const uint tab, FILE *where )
{
    FILE *out = ( where ? where : stdout );

    fprintf( out, "{ -- TrackAI '%s'\n", AI_TRACKAI_FILE );

    fprintf( out, "\tdwStart       = 0x%08X\n", dwStart );
    fprintf( out, "\tdwNSplineList = %d\n",     dwNSplineList );
    for( uint i = 0; i < dwNSplineList; ++i ) {
        splineList[i].show( 1, where );
    }
    fprintf( out, "\tdwStartPt     = 0x%08X\n", dwStartPt );
    startPtList.show( 1, where );
    splitPtList.show( 1, where );
    fprintf( out, "\tdwEndPt       = 0x%08X\n", dwEndPt );
    fprintf( out, "\tdwStartBd     = 0x%08X\n", dwStartBd );
    borderList.show( 1, where );
    fprintf( out, "\tdwEndBd       = 0x%08X\n", dwEndBd );
    unknownList.show( 1, where );
    fprintf( out, "\tdwEnd         = 0x%08X\n", dwStart );

    fprintf( out, "} -- TrackAI\n" );

    fflush( out );
} // End proc cTrackAI::show


#if !defined(NO_BLENDER)
//-----------------------------------------------------------------------------
// Name   : addCurve
// Usage  : Add 3D poly curve
// Args   :--------------------------------------------------------------------
//              NAME      |IN.|OUT|          DESCRIPTION
//         --------------------------------------------------------------------
//         points           X   -   Vector of 
//         name             X   -   Name of curve
//         cyclic           X   -   Cyclic flag
//         
// Return : Pointer to new Curve object or NULL
//-----------------------------------------------------------------------------
Object *addCurve( vector<BPoint> &points, const char *name, const bool cyclic )
{
    Object *ob= NULL;
    Curve *cu= NULL;
    Nurb *nu= NULL;
    uint nbPt = points.size();

    do {
        if( 0 == nbPt || !name ) break;

        nu = (Nurb*)MEM_callocN( sizeof(Nurb), "FO2_Nurb" );
        if( !nu ) break;

        nu->bp= (BPoint*)MEM_callocN( nbPt*sizeof(BPoint), "FO2_Nurb2");
        if( !nu->bp ) {
            MEM_freeN( nu );
            break;
        }

        nu->type= CU_POLY;
        if( cyclic ) nu->flagu= CU_CYCLIC;
        nu->resolu= 6;
        nu->resolv= 6;
        nu->pntsu= nbPt;
        nu->pntsv= 1;
        nu->orderu= 4;

        ob = add_object( OB_CURVE );
        cu = (Curve*)ob->data;
        cu->flag= CU_3D;

        // Copy points
        for( uint i = 0; i < nbPt; ++i ) {
            nu->bp[i] = points[i];
        }

        BLI_addtail( &cu->nurb, nu );

        rename_id( &ob->id, (char*)name );
    } while(0);

    return( ob );
} // End addCurve
#endif //NO_BLENDER


//-- End of file : FO2trackAI.cpp  --
